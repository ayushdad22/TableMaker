<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Incrementer</title>
</head>
<body>
    <textarea id="textBox" rows="10" cols="50" placeholder="Enter values like @0num3@, @hex1anum4cap@, or @binary0num4@"></textarea><br>

    <label>Start Character: <input type="text" id="startChar" placeholder="Enter start character" maxlength="1" value="@"></label><br>
    <label>End Character: <input type="text" id="endChar" placeholder="Enter end character" maxlength="1" value="@"></label><br>
    <label>Increment Count: <input type="number" id="incrementsCount" placeholder="Number of increments" value="5"></label><br>
    <label>Increment Step: <input type="number" id="incrementStep" placeholder="Increment step" value="1"></label><br>
    <label><input type="checkbox" id="reverseNegative"> Reverse order if negative increments</label><br>

    <button onclick="myFunction()">Submit</button>
    <pre id="output"></pre>

    <script>
    const textBox = document.getElementById("textBox");
    const output = document.getElementById("output");

    const checkValue = (text, startChar, endChar) => {
        const regex = new RegExp(`\\${startChar}(.*?)\\${endChar}`, 'g');
        let matches = [];
        let match;

        while ((match = regex.exec(text)) !== null) {
            let extractedValue = match[1];
            let base = 10; // Default base is decimal
            let paddingLength = 0; // Default padding length is 0
            let uppercaseHex = false; // Only apply uppercase if 'cap' is found for hex

            extractedValue = extractedValue.trim().toLowerCase();

            // Determine the base and strip the base identifier
            if (extractedValue.startsWith('hex')) {
                base = 16;
                extractedValue = extractedValue.slice(3).trim();

                // Check for 'cap' at the end for uppercase hex
                if (extractedValue.endsWith('cap')) {
                    uppercaseHex = true;
                    extractedValue = extractedValue.slice(0, -3).trim();
                }

                if (extractedValue.startsWith('convert')) {
                    extractedValue = extractedValue.slice(7).trim();
                    extractedValue = parseInt(extractedValue).toString(16);
                }
            } else if (extractedValue.startsWith('binary')) {
                base = 2;
                extractedValue = extractedValue.slice(6).trim();
            }

            // Extract padding length if specified
            let paddingMatch = extractedValue.match(/(.*)num(\d+)/);
            let initialValue = extractedValue;
            if (paddingMatch) {
                initialValue = paddingMatch[1].trim();
                paddingLength = parseInt(paddingMatch[2], 10);
            }

            // If initialValue is empty, default to '0'
            if (!initialValue) {
                initialValue = '0';
            }

            matches.push({ value: initialValue, base: base, padding: paddingLength, uppercaseHex: uppercaseHex });
        }
        return matches;
    };

    const incrementValue = (values, incrementsCount, incrementStep, reverseNegative) => {
        let result = [];

        values.forEach(item => {
            let { value, base, padding, uppercaseHex } = item;
            let incrementedValues = [];

            // Parse the initial value with the correct base
            let initialValue = parseInt(value, base);

            // Generate increments
            for (let i = 0; i <= incrementsCount; i++) {
                let incrementedValue = initialValue + i * incrementStep;
                let formattedValue = incrementedValue.toString(base);

                // Pad with leading zeros if padding is specified
                if (padding > 0) {
                    formattedValue = formattedValue.padStart(padding, '0');
                }

                // If base is hex and 'cap' was specified, convert to uppercase
                if (base === 16 && uppercaseHex) {
                    formattedValue = formattedValue.toUpperCase();
                }

                incrementedValues.push(formattedValue);
            }

            // If increments are negative and reverseNegative is checked, reverse the order
            if (incrementStep < 0 && reverseNegative) {
                incrementedValues.reverse();
            }

            result.push(incrementedValues);
        });

        return result;
    };

    function printSentenceWithIncrements(sentence, increments, startChar, endChar) {
        let fullOutput = "";

        if (increments.length === 0 || increments[0].length === 0) {
            fullOutput = "No valid values found between the specified characters.";
            return fullOutput;
        }

        const n = increments[0].length;
        const placeholderRegex = new RegExp(`\\${startChar}(.*?)\\${endChar}`, 'g');
        const placeholders = [];
        let match;
        while ((match = placeholderRegex.exec(sentence)) !== null) {
            placeholders.push(match[0]);
        }

        for (let i = 0; i < n; i++) {
            let modifiedSentence = sentence;
            for (let j = 0; j < placeholders.length; j++) {
                const placeholder = placeholders[j];
                const value = increments[j][i];
                modifiedSentence = modifiedSentence.replace(placeholder, value);
            }
            fullOutput += `${modifiedSentence}\n`;
        }
        return fullOutput;
    }

    function myFunction() {
        const originalText = textBox.value;
        const startChar = document.getElementById("startChar").value.trim();
        const endChar = document.getElementById("endChar").value.trim();
        const incrementsCount = parseInt(document.getElementById("incrementsCount").value, 10);
        const incrementStep = parseInt(document.getElementById("incrementStep").value, 10);
        const reverseNegative = document.getElementById("reverseNegative").checked;

        if (!startChar || !endChar) {
            output.innerHTML = "Please provide both start and end characters.";
            return;
        }

        const values = checkValue(originalText, startChar, endChar);

        if (values.length === 0) {
            output.innerHTML = "No valid values found between the specified characters.";
            return;
        }

        const increments = incrementValue(values, incrementsCount, incrementStep, reverseNegative);
        output.innerHTML = printSentenceWithIncrements(originalText, increments, startChar, endChar);
    }
    </script>
</body>
</html>
